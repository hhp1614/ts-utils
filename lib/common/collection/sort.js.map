{"version":3,"file":"sort.js","sourceRoot":"","sources":["../../../src/common/collection/sort.ts"],"names":[],"mappings":"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","sourcesContent":["import { getType, isObject } from '../type';\n\ntype Item = string | number | Obj;\ntype Arr = Array<Item>;\ntype Obj = { [key: string]: any };\n\ntype ArrayOrObject = Arr | Obj;\n\n/**\n * 快速排序\n * @param arr 需要快速排序的数组\n * @param order `asc`：升序，`desc`：降序，默认 `asc`\n */\nfunction quickSort(arr: Arr, order: 'asc' | 'desc' = 'asc') {\n  // 将小于基数的数放到基数左边，大于基数的数放到右边，并返回基数的位置\n  const partition = (arr: Arr, left: number, right: number) => {\n    // 取第一个数为基数\n    const temp = arr[left] ?? null;\n    while (left < right) {\n      const agreeTypes = ['number', 'string'];\n      const leftType = getType(arr[left]);\n      const rightType = getType(arr[right]);\n      if (!agreeTypes.includes(leftType) || !agreeTypes.includes(rightType)) {\n        throw new TypeError('数组的 `item` 必须是 `number` 或 `string`');\n      }\n      if (order !== 'desc') {\n        // 升序\n        while (left < right && arr[right] >= temp) {\n          right--;\n        }\n        arr[left] = arr[right];\n        while (left < right && arr[left] < temp) {\n          left++;\n        }\n        arr[right] = arr[left];\n      } else {\n        // 降序\n        while (left < right && arr[right] <= temp) {\n          right--;\n        }\n        arr[left] = arr[right];\n        while (left < right && arr[left] > temp) {\n          left++;\n        }\n        arr[right] = arr[left];\n      }\n    }\n    // 修改基数的位置\n    arr[left] = temp;\n    return left;\n  };\n\n  // 递归排序基数左右两边的序列\n  const recursive = (arr: Arr, left: number, right: number) => {\n    if (left >= right) {\n      return arr;\n    }\n    let index = partition(arr, left, right);\n    recursive(arr, left, index - 1);\n    recursive(arr, index + 1, right);\n    return arr;\n  };\n\n  return recursive(arr, 0, arr.length - 1);\n}\n\n/**\n * 排序\n * @description 支持排序 `item` 为 `number` 或 `string` 的数组\n * @description 支持排序对象数组\n * @description 支持排序对象\n * @param value 需要排序的数组或对象\n * @param order `asc`：升序，`desc`：降序，默认 `asc`\n * @param key 排序对象数组时，指定排序的 `key`\n */\nexport function sort(value: ArrayOrObject, order: 'asc' | 'desc' = 'asc', key?: string): ArrayOrObject {\n  // 原地排序对象数组，根据对象的 key 值排序\n  if (key && Array.isArray(value)) {\n    // 提取所有的 key 值\n    const srcKeys = value.map((i: Obj) => i && i[key]);\n\n    // 如果 key 存在不合法的值，直接返回原数组\n    if (!srcKeys.every(i => typeof i === 'number' || typeof i === 'string')) {\n      return value;\n    }\n\n    // 根据 key 值排序\n    const keys: any[] = quickSort(srcKeys, order);\n    // 存储原始数组\n    const data = [...value];\n    // 将原数组清空\n    value.length = 0;\n    // 如果为倒序，就翻转原数组\n    if (order === 'desc') {\n      data.reverse();\n    }\n\n    keys.forEach(k => {\n      // 查找排序后数据对应的下标\n      const i = data.findIndex(i => i && (i as Obj)[key] === k);\n      // 插入到原数组中\n      value.push(data[i]);\n      // 删除缓存的数据，防止重复插入\n      delete data[i];\n    });\n\n    // 返回排序后的原数组\n    return value;\n  }\n\n  // 原地排序数组\n  if (Array.isArray(value)) {\n    // 快速排序\n    return quickSort(value, order);\n  }\n\n  // 原地排序对象\n  if (isObject(value)) {\n    const keys = quickSort(Object.keys(value), order);\n    keys.forEach((key: string) => {\n      const temp = value[key];\n      delete value[key];\n      value[key] = temp;\n    });\n    return value;\n  }\n\n  // 不是数组或对象时，返回原值\n  return value;\n}\n"]}
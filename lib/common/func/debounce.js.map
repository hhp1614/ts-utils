{"version":3,"file":"debounce.js","sourceRoot":"","sources":["../../../src/common/func/debounce.ts"],"names":[],"mappings":";;;AAAA,gCAA+C;AAE/C;;;;;;;GAOG;AACH,SAAgB,QAAQ,CAAC,IAAc,EAAE,IAAY,EAAE,SAAiB;IAAjB,0BAAA,EAAA,iBAAiB;IACtE,IAAI,CAAC,iBAAU,CAAC,IAAI,CAAC,EAAE;QACrB,MAAM,IAAI,SAAS,CAAC,cAAc,CAAC,CAAC;KACrC;IACD,IAAI,CAAC,eAAQ,CAAC,IAAI,CAAC,EAAE;QACnB,MAAM,IAAI,SAAS,CAAC,cAAc,CAAC,CAAC;KACrC;IAED,IAAI,OAAY,CAAC;IAEjB,IAAM,SAAS,GAAG;QAAA,iBAoBjB;QApB2B,cAAmB;aAAnB,UAAmB,EAAnB,qBAAmB,EAAnB,IAAmB;YAAnB,yBAAmB;;QAC7C,IAAI,OAAO,EAAE;YACX,YAAY,CAAC,OAAO,CAAC,CAAC;SACvB;QACD,IAAI,SAAS,EAAE;YACb,sCAAsC;YACtC,IAAM,OAAO,GAAG,CAAC,OAAO,CAAC;YACzB,OAAO,GAAG,UAAU,CAAC;gBACnB,OAAO,GAAG,IAAI,CAAC;YACjB,CAAC,EAAE,IAAI,CAAC,CAAC;YACT,IAAI,OAAO,EAAE;gBACX,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;aACxB;SACF;aAAM;YACL,+BAA+B;YAC/B,OAAO,GAAG,UAAU,CAAC;gBACnB,IAAI,CAAC,KAAK,CAAC,KAAI,EAAE,IAAI,CAAC,CAAC;gBACvB,OAAO,GAAG,IAAI,CAAC;YACjB,CAAC,EAAE,IAAI,CAAC,CAAC;SACV;IACH,CAAC,CAAC;IAEF;;OAEG;IACH,SAAS,CAAC,MAAM,GAAG;QACjB,YAAY,CAAC,OAAO,CAAC,CAAC;QACtB,OAAO,GAAG,IAAI,CAAC;IACjB,CAAC,CAAC;IAEF,OAAO,SAAS,CAAC;AACnB,CAAC;AAzCD,4BAyCC","sourcesContent":["import { isFunction, isNumber } from '../type';\n\n/**\n * 函数防抖\n * @description 限制事件的频繁触发\n * @description 将需要延迟执行的函数(`func`)在函数(`debounce`)最后一次调用时的 `wait` 毫秒后执行\n * @param func 需要防抖处理的函数\n * @param wait 延迟执行的时间，单位毫秒\n * @param immediate 是否立即执行，默认 `false`\n */\nexport function debounce(func: Function, wait: number, immediate = false) {\n  if (!isFunction(func)) {\n    throw new TypeError('`func` 必须是函数');\n  }\n  if (!isNumber(wait)) {\n    throw new TypeError('`wait` 必须是数字');\n  }\n\n  let timeout: any;\n\n  const debounced = function (...args: Array<any>) {\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    if (immediate) {\n      // 立即执行函数，wait 毫秒内不再执行函数才可以重新触发执行 func\n      const callNow = !timeout;\n      timeout = setTimeout(() => {\n        timeout = null;\n      }, wait);\n      if (callNow) {\n        func.apply(this, args);\n      }\n    } else {\n      // 执行完函数 wait 毫秒后才可以重新触发执行 func\n      timeout = setTimeout(() => {\n        func.apply(this, args);\n        timeout = null;\n      }, wait);\n    }\n  };\n\n  /**\n   * 取消防抖\n   */\n  debounced.cancel = () => {\n    clearTimeout(timeout);\n    timeout = null;\n  };\n\n  return debounced;\n}\n"]}
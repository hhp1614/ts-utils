{"version":3,"file":"throttle.js","sourceRoot":"","sources":["../../../src/common/func/throttle.ts"],"names":[],"mappings":";;;AAAA,gCAA8D;AAE9D;;;;;;;;;;GAUG;AACH,SAAgB,QAAQ,CAAC,IAAc,EAAE,IAAY,EAAE,OAAuD;IAAvD,wBAAA,EAAA,YAAuD;IAC5G,IAAI,CAAC,iBAAU,CAAC,IAAI,CAAC,EAAE;QACrB,MAAM,IAAI,SAAS,CAAC,cAAc,CAAC,CAAC;KACrC;IACD,IAAI,CAAC,eAAQ,CAAC,IAAI,CAAC,EAAE;QACnB,MAAM,IAAI,SAAS,CAAC,cAAc,CAAC,CAAC;KACrC;IACD,IAAI,CAAC,oBAAa,CAAC,OAAO,CAAC,EAAE;QAC3B,MAAM,IAAI,SAAS,CAAC,mBAAmB,CAAC,CAAC;KAC1C;IAED,IAAI,OAAY,CAAC;IACjB,IAAI,QAAQ,GAAG,CAAC,CAAC;IAEjB,IAAM,SAAS,GAAG;QAAA,iBAqBjB;QArB2B,cAAmB;aAAnB,UAAmB,EAAnB,qBAAmB,EAAnB,IAAmB;YAAnB,yBAAmB;;QAC7C,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,0BAA0B;QAC1B,IAAI,CAAC,QAAQ,IAAI,OAAO,CAAC,OAAO,KAAK,KAAK;YAAE,QAAQ,GAAG,GAAG,CAAC;QAC3D,kBAAkB;QAClB,IAAM,SAAS,GAAG,IAAI,GAAG,CAAC,GAAG,GAAG,QAAQ,CAAC,CAAC;QAC1C,oBAAoB;QACpB,IAAI,SAAS,IAAI,CAAC,IAAI,GAAG,GAAG,QAAQ,EAAE;YACpC,IAAI,OAAO,EAAE;gBACX,YAAY,CAAC,OAAO,CAAC,CAAC;gBACtB,OAAO,GAAG,IAAI,CAAC;aAChB;YACD,QAAQ,GAAG,GAAG,CAAC;YACf,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SACxB;aAAM,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,QAAQ,KAAK,KAAK,EAAE;YACjD,OAAO,GAAG,UAAU,CAAC;gBACnB,QAAQ,GAAG,OAAO,CAAC,OAAO,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;gBACtD,OAAO,GAAG,IAAI,CAAC;gBACf,IAAI,CAAC,KAAK,CAAC,KAAI,EAAE,IAAI,CAAC,CAAC;YACzB,CAAC,EAAE,SAAS,CAAC,CAAC;SACf;IACH,CAAC,CAAC;IAEF;;OAEG;IACH,SAAS,CAAC,MAAM,GAAG;QACjB,YAAY,CAAC,OAAO,CAAC,CAAC;QACtB,QAAQ,GAAG,CAAC,CAAC;QACb,OAAO,GAAG,IAAI,CAAC;IACjB,CAAC,CAAC;IAEF,OAAO,SAAS,CAAC;AACnB,CAAC;AA/CD,4BA+CC","sourcesContent":["import { isFunction, isNumber, isPlainObject } from '../type';\r\n\r\n/**\r\n * 函数节流\r\n * @description 创建并返回一个像节流阀一样的函数，当重复调用函数的时候，至少每隔 `wait` 毫秒调用一次该函数\r\n * @description 对于想控制一些触发频率较高的事件有帮助\r\n * @description 默认情况下，`throttle` 将在调用的第一时间尽快执行这个 `func`（第一次和最后一次都执行 `func`）\r\n * @param func 需要节流处理的函数\r\n * @param wait 延迟执行的时间，单位毫秒\r\n * @param options 选项，默认 `{}`\r\n * @param options.leading 如果想禁用第一次首先执行的话，传递 `{ leading: false }`\r\n * @param options.trailing 如果想禁用最后一次执行的话，传递 `{ trailing: false }`\r\n */\r\nexport function throttle(func: Function, wait: number, options: { leading?: boolean; trailing?: boolean } = {}) {\r\n  if (!isFunction(func)) {\r\n    throw new TypeError('`func` 必须是函数');\r\n  }\r\n  if (!isNumber(wait)) {\r\n    throw new TypeError('`wait` 必须是数字');\r\n  }\r\n  if (!isPlainObject(options)) {\r\n    throw new TypeError('`options` 必须是普通对象');\r\n  }\r\n\r\n  let timeout: any;\r\n  let previous = 0;\r\n\r\n  const throttled = function (...args: Array<any>) {\r\n    const now = Date.now();\r\n    // leading：false 表示禁用第一次执行\r\n    if (!previous && options.leading === false) previous = now;\r\n    // 下次触发 func 剩余的时间\r\n    const remaining = wait - (now - previous);\r\n    // 如果没有剩余时间了或者改了系统时间\r\n    if (remaining <= 0 || now < previous) {\r\n      if (timeout) {\r\n        clearTimeout(timeout);\r\n        timeout = null;\r\n      }\r\n      previous = now;\r\n      func.apply(this, args);\r\n    } else if (!timeout && options.trailing !== false) {\r\n      timeout = setTimeout(() => {\r\n        previous = options.leading === false ? 0 : Date.now();\r\n        timeout = null;\r\n        func.apply(this, args);\r\n      }, remaining);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * 取消节流\r\n   */\r\n  throttled.cancel = () => {\r\n    clearTimeout(timeout);\r\n    previous = 0;\r\n    timeout = null;\r\n  };\r\n\r\n  return throttled;\r\n}\r\n"]}
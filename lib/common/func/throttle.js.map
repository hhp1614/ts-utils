{"version":3,"file":"throttle.js","sourceRoot":"","sources":["../../../src/common/func/throttle.ts"],"names":[],"mappings":";;;AAAA,gCAA8D;AAE9D;;;;;;;;;;GAUG;AACH,SAAgB,QAAQ,CAAC,IAAc,EAAE,IAAY,EAAE,OAAuD;IAAvD,wBAAA,EAAA,YAAuD;IAC5G,IAAI,CAAC,iBAAU,CAAC,IAAI,CAAC,EAAE;QACrB,MAAM,IAAI,SAAS,CAAC,cAAc,CAAC,CAAC;KACrC;IACD,IAAI,CAAC,eAAQ,CAAC,IAAI,CAAC,EAAE;QACnB,MAAM,IAAI,SAAS,CAAC,cAAc,CAAC,CAAC;KACrC;IACD,IAAI,CAAC,oBAAa,CAAC,OAAO,CAAC,EAAE;QAC3B,MAAM,IAAI,SAAS,CAAC,mBAAmB,CAAC,CAAC;KAC1C;IAED,IAAI,OAAY,CAAC;IACjB,IAAI,QAAQ,GAAG,CAAC,CAAC;IAEjB,IAAM,SAAS,GAAG;QAAA,iBAqBjB;QArB2B,cAAmB;aAAnB,UAAmB,EAAnB,qBAAmB,EAAnB,IAAmB;YAAnB,yBAAmB;;QAC7C,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,0BAA0B;QAC1B,IAAI,CAAC,QAAQ,IAAI,OAAO,CAAC,OAAO,KAAK,KAAK;YAAE,QAAQ,GAAG,GAAG,CAAC;QAC3D,kBAAkB;QAClB,IAAM,SAAS,GAAG,IAAI,GAAG,CAAC,GAAG,GAAG,QAAQ,CAAC,CAAC;QAC1C,oBAAoB;QACpB,IAAI,SAAS,IAAI,CAAC,IAAI,GAAG,GAAG,QAAQ,EAAE;YACpC,IAAI,OAAO,EAAE;gBACX,YAAY,CAAC,OAAO,CAAC,CAAC;gBACtB,OAAO,GAAG,IAAI,CAAC;aAChB;YACD,QAAQ,GAAG,GAAG,CAAC;YACf,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SACxB;aAAM,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,QAAQ,KAAK,KAAK,EAAE;YACjD,OAAO,GAAG,UAAU,CAAC;gBACnB,QAAQ,GAAG,OAAO,CAAC,OAAO,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;gBACtD,OAAO,GAAG,IAAI,CAAC;gBACf,IAAI,CAAC,KAAK,CAAC,KAAI,EAAE,IAAI,CAAC,CAAC;YACzB,CAAC,EAAE,SAAS,CAAC,CAAC;SACf;IACH,CAAC,CAAC;IAEF;;OAEG;IACH,SAAS,CAAC,MAAM,GAAG;QACjB,YAAY,CAAC,OAAO,CAAC,CAAC;QACtB,QAAQ,GAAG,CAAC,CAAC;QACb,OAAO,GAAG,IAAI,CAAC;IACjB,CAAC,CAAC;IAEF,OAAO,SAAS,CAAC;AACnB,CAAC;AA/CD,4BA+CC","sourcesContent":["import { isFunction, isNumber, isPlainObject } from '../type';\n\n/**\n * 函数节流\n * @description 创建并返回一个像节流阀一样的函数，当重复调用函数的时候，至少每隔 `wait` 毫秒调用一次该函数\n * @description 对于想控制一些触发频率较高的事件有帮助\n * @description 默认情况下，`throttle` 将在调用的第一时间尽快执行这个 `func`（第一次和最后一次都执行 `func`）\n * @param func 需要节流处理的函数\n * @param wait 延迟执行的时间，单位毫秒\n * @param options 选项，默认 `{}`\n * @param options.leading 如果想禁用第一次首先执行的话，传递 `{ leading: false }`\n * @param options.trailing 如果想禁用最后一次执行的话，传递 `{ trailing: false }`\n */\nexport function throttle(func: Function, wait: number, options: { leading?: boolean; trailing?: boolean } = {}) {\n  if (!isFunction(func)) {\n    throw new TypeError('`func` 必须是函数');\n  }\n  if (!isNumber(wait)) {\n    throw new TypeError('`wait` 必须是数字');\n  }\n  if (!isPlainObject(options)) {\n    throw new TypeError('`options` 必须是普通对象');\n  }\n\n  let timeout: any;\n  let previous = 0;\n\n  const throttled = function (...args: Array<any>) {\n    const now = Date.now();\n    // leading：false 表示禁用第一次执行\n    if (!previous && options.leading === false) previous = now;\n    // 下次触发 func 剩余的时间\n    const remaining = wait - (now - previous);\n    // 如果没有剩余时间了或者改了系统时间\n    if (remaining <= 0 || now < previous) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(this, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(this, args);\n      }, remaining);\n    }\n  };\n\n  /**\n   * 取消节流\n   */\n  throttled.cancel = () => {\n    clearTimeout(timeout);\n    previous = 0;\n    timeout = null;\n  };\n\n  return throttled;\n}\n"]}
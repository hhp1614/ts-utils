{"version":3,"file":"clone.js","sourceRoot":"","sources":["../../../src/common/object/clone.ts"],"names":[],"mappings":";;;AAAA,gCAAiC;AAEjC,qBAAqB;AACrB,IAAM,KAAK,GAAG,IAAI,GAAG,EAAE,CAAA;AAEvB;;;GAGG;AACH,SAAgB,KAAK,CAAC,KAAU;IAC9B,gBAAgB;IAChB,IAAI,CAAC,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QACvC,OAAO,KAAK,CAAA;KACb;IAED,YAAY;IACZ,QAAQ,cAAO,CAAC,KAAK,CAAC,EAAE;QACtB,KAAK,MAAM;YACT,OAAO,IAAI,IAAI,CAAC,KAAK,CAAC,CAAA;QACxB,KAAK,QAAQ;YACX,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,CAAA;QAC1B,KAAK,QAAQ,CAAC;QACd,KAAK,QAAQ,CAAC;QACd,KAAK,SAAS;YACZ,OAAO,MAAM,CAAC,KAAK,CAAC,CAAA;KACvB;IAED,eAAe;IACf,IAAI,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;QACpB,OAAO,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;KACxB;IAED,OAAO;IACP,IAAM,MAAM,GAAQ,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAA;IAEpD,OAAO;IACP,KAAK,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAA;IAExB,KAAK,IAAM,QAAQ,IAAI,KAAK,EAAE;QAC5B,IAAI,KAAK,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE;YAClC,WAAW;YACX,MAAM,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAA;SAC1C;KACF;IAED,OAAO,MAAM,CAAA;AACf,CAAC;AArCD,sBAqCC","sourcesContent":["import { getType } from '../type'\n\n// 将父层级的数据缓存对比，解决循环引用\nconst cache = new Map()\n\n/**\n * 深拷贝\n * @param value 任意值\n */\nexport function clone(value: any) {\n  // 非引用类型及函数将直接返回\n  if (!value || typeof value !== 'object') {\n    return value\n  }\n\n  // 特殊的引用类型处理\n  switch (getType(value)) {\n    case 'date':\n      return new Date(value)\n    case 'regexp':\n      return new RegExp(value)\n    case 'string':\n    case 'number':\n    case 'boolean':\n      return Object(value)\n  }\n\n  // 如果缓存中存在就直接返回\n  if (cache.get(value)) {\n    return cache.get(value)\n  }\n\n  // 存储结果\n  const result: any = value instanceof Array ? [] : {}\n\n  // 存入缓存\n  cache.set(value, result)\n\n  for (const propName in value) {\n    if (value.hasOwnProperty(propName)) {\n      // 递归 clone\n      result[propName] = clone(value[propName])\n    }\n  }\n\n  return result\n}\n"]}
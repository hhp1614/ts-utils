{"version":3,"file":"clone.js","sourceRoot":"","sources":["../../../src/common/object/clone.ts"],"names":[],"mappings":";;;AAAA,gCAAkC;AAElC,qBAAqB;AACrB,IAAM,KAAK,GAAG,IAAI,GAAG,EAAE,CAAC;AAExB;;;GAGG;AACH,SAAgB,KAAK,CAAC,KAAU;IAC9B,gBAAgB;IAChB,IAAI,CAAC,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QACvC,OAAO,KAAK,CAAC;KACd;IAED,YAAY;IACZ,QAAQ,cAAO,CAAC,KAAK,CAAC,EAAE;QACtB,KAAK,MAAM;YACT,OAAO,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC;QACzB,KAAK,QAAQ;YACX,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC;QAC3B,KAAK,QAAQ,CAAC;QACd,KAAK,QAAQ,CAAC;QACd,KAAK,SAAS;YACZ,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;KACxB;IAED,eAAe;IACf,IAAI,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;QACpB,OAAO,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;KACzB;IAED,OAAO;IACP,IAAM,MAAM,GAAQ,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;IAErD,OAAO;IACP,KAAK,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IAEzB,KAAK,IAAM,QAAQ,IAAI,KAAK,EAAE;QAC5B,IAAI,KAAK,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE;YAClC,WAAW;YACX,MAAM,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;SAC3C;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AArCD,sBAqCC","sourcesContent":["import { getType } from '../type';\r\n\r\n// 将父层级的数据缓存对比，解决循环引用\r\nconst cache = new Map();\r\n\r\n/**\r\n * 深拷贝\r\n * @param value 任意值\r\n */\r\nexport function clone(value: any) {\r\n  // 非引用类型及函数将直接返回\r\n  if (!value || typeof value !== 'object') {\r\n    return value;\r\n  }\r\n\r\n  // 特殊的引用类型处理\r\n  switch (getType(value)) {\r\n    case 'date':\r\n      return new Date(value);\r\n    case 'regexp':\r\n      return new RegExp(value);\r\n    case 'string':\r\n    case 'number':\r\n    case 'boolean':\r\n      return Object(value);\r\n  }\r\n\r\n  // 如果缓存中存在就直接返回\r\n  if (cache.get(value)) {\r\n    return cache.get(value);\r\n  }\r\n\r\n  // 存储结果\r\n  const result: any = value instanceof Array ? [] : {};\r\n\r\n  // 存入缓存\r\n  cache.set(value, result);\r\n\r\n  for (const propName in value) {\r\n    if (value.hasOwnProperty(propName)) {\r\n      // 递归 clone\r\n      result[propName] = clone(value[propName]);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n"]}